JVM虚拟机

## Java虚拟机的发展史

### 虚拟机始祖： Sun Classic/Exact VM  

### 武林盟主HotSpot VM

 JDK 1.3时， HotSpot VM成为默认虚拟机 ， 它名称中的HotSpot指的就是它的热点代码探测技术  ，HotSpot虚拟机的热点代码探测能力可以通过执行计数器
找出最具有编译价值的代码， 然后通知即时编译器以方法为单位进行编译。 如果一个方法被频繁调
用， 或方法中有效循环次数很多， 将会分别触发标准即时编译和栈上替换编译（On-StackReplacement， OSR） 行为[1]。   

通过编译器与解释器恰当地协同工作， 可以在最优化的程序响应时间与
最佳执行性能中取得平衡， 而且无须等待本地代码输出才能执行程序， 即时编译的时间压力也相对减
小， 这样有助于引入更复杂的代码优化技术， 输出质量更高的本地代码。  



### 小家碧玉： Mobile/Embedded VM  

手机上的虚拟机

### 天下第二： BEA JRockit/IBM J9 VM  

因此JRockit内部不包含解释器实现， 全部代
码都靠即时编译器编译后执行。 除此之外， JRockit的垃圾收集器和Java Mission Control故障处理套件
等部分的实现， 在当时众多的Java虚拟机中也处于领先水平。 JRockit随着BEA被Oracle收购， 现已不再
继续发展， 永远停留在R28版本， 这是JDK 6版JRockit的代号  

### 软硬合璧： BEA Liquid VM/Azul VM  

软硬件配合工作的专有虚拟机  

这类专有虚拟机的代表是BEA Liquid VM和Azul VM。  

### 挑战者： Apache Harmony/Google Android Dalvik VM  

尤其是对Android的发展起了很大推动作用。  

### 没有成功， 但并非失败： Microsoft JVM及其他  

### 百家争鸣  

KVM中的K是“Kilobyte”的意思， 它强调简单、 轻量、 高度可移植， 但是运行速度比较慢。 在
Android、 iOS等智能手机操作系统出现前曾经在手机平台上得到非常广泛应用。  

Java Card VM
JCVM是Java虚拟机很小的一个子集， 裁减了许多模块但通常支持绝大多数的常用加密算法。
JCVM必须精简到能放入智能卡、 SIM卡、 银行信用卡、 借记卡内， 负责对Java Applet程序进行解释执行。
·Squawk VM
Squawk VM是由Sun开发， 运行于Sun SPOT（Sun Small Programmable Object Tech-nology， 一种手持的Wi-Fi设备） ， 也曾经运用于Java Card。 这是一个Java代码比重很高的嵌入式虚拟机实现， 其中诸如类加载器、 字节码验证器、 垃圾收集器、 解释器、 编译器和线程调度都是用Java语言完成的， 仅仅靠C语言编写设备I/O和必要的本地代码。
·JavaInJava
JavaInJava是Sun公司在1997年～1998年间所研发的一个实验室性质的虚拟机， 从名字就可以看出， 它试图以Java语言来实现Java语言本身的运行环境， 既所谓的“元循环”（Meta-Circular， 是指使用
语言自身来实现其运行环境） 虚拟机。 它必须运行在另外一个宿主虚拟机之上， 内部没有即时编译器， 代码只能以解释模式执行。 在上世纪末主流原生的Java虚拟机都未能很好解决性能问题的时代，
开发这种项目， 其执行速度大家可想而知， 不过通过元循环证明一门语言可以自举， 是具有它的研究价值的。
·Maxine VM
Maxine VM和上面的JavaInJava非常相似， 它也是一个几乎全部以Java代码实现（只有用于启动Java虚拟机的加载器使用C语言编写） 的元循环Java虚拟机。 这个项目于2005年开始， 到现在仍然在发
展之中， 比起JavaInJava， Maxine VM的执行效率就显得靠谱得多， 它有先进的即时编译器和垃圾收集
器， 可在宿主模式或独立模式下执行， 其执行效率已经接近HotSpot虚拟机Client模式的水平。 后来有
了从C1X编译器演进而来的Graal编译器的支持， 就更加如虎添翼， 执行效率有了进一步飞跃。 Graal编
译器现在已经是HotSpot的默认组件， 是未来代替HotSpot中服务端编译器的希望。
·Jikes RVM
Jikes RVM是IBM开发的专门用来研究Java虚拟机实现技术的项目。 曾用名为Jalapeño。 与
JavaInJava和Maxine一样， 它也是一个元循环虚拟机。
·IKVM.NET
这是一个基于微软.NET框架实现的Java虚拟机， 并借助Mono获得一定的跨平台能力。 IKVM.NET
的目标第一眼看起来的确很奇怪， 可能在某些特殊情况下， 在.NET上使用某些流行的Java库也许真的
不算是伪需求？ IKVM.NET可以将Class文件编译成.NET Assembly， 在任意的CLI上运行。  

## 自动内存管理

### 运行时数据区域

#### 程序计数器

当前线程所执行的行号指示器，此内存区域不会发生OutOfMemoryError

#### 虚拟机栈

线程私有

生命周期与线程相同

方法执行会创建**栈帧**，栈帧中存储局部变量表，操作数栈，动态连接，方法出口信息等。

一个方法的调用和完成对应一个栈帧的入栈和出栈。

局部变量表中存放了编译期可知的8种基本数据类型，对象引用和字节码指令的地址。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot） 来表示， 其中64位长度的long和double类型的数据会占用两个变量槽， 其余的数据类型只占用一个。   



HotSpot虚拟机的栈容量是不可以动态扩展的  

#### 本地方法栈

本地方法栈（Native Method Stacks） 与虚拟机栈所发挥的作用是非常相似的， 其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码） 服务， 而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。  

与虚拟机栈一样， 本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。  

#### Java堆

Java堆（Java Heap） 是虚拟机所管理的内存中最大的一块  ，**线程共享**。

此内存区域的唯一目的就是存放**对象实例**  和**数组**

Java堆是垃圾收集器管理的内存区域 ，因为被叫GC堆

Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空
间”“To Survivor空间”等名词  。

Java堆既可以被实现成固定大小的， 也可以是可扩展的， 不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定） 。 如果在Java堆中没有内存完成实例分配， 并且堆也无法再扩展时， Java虚拟机将会抛出OutOfMemoryError异常。  

#### 方法区

与Java堆一样都是线程共享的，用于存储虚拟机加载的类型信息，**常量**，静态变量，即时编译器编译后的代码缓存等信息，。

永久代实现方法区

jdk1.8 以后方法区被放入java内存中，有操作系统管理

#### 运行时常量池

运行时常量池（Runtime Constant Pool） 是方法区的一部分。 Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外， 还有一项信息是常量池表（Constant Pool Table） ， 用于存放编译期生成的各种字面量与符号引用， 这部分内容将在类加载后存放到方法区的运行时常量池中。  

既然运行时常量池是方法区的一部分， 自然受到方法区内存的限制， 当常量池无法再申请到内存
时会抛出OutOfMemoryError异常。  

#### 直接内存

直接内存（Direct Memory）,不是虚拟机运行时数据区，这部分内存也被频繁地使用， 而且也可能导致OutOfMemoryError异常出现  。

在JDK 1.4中新加入了NIO（New Input/Output） 类， 引入了一种基于通道（Channel） 与缓冲区（Buffer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据  。

## HotSpot虚拟机对象探秘  

### 对象的创建

new关键字，给对象在堆内存上给对象分配内存。

**指针碰撞**：java堆内存时绝对规整的，空闲的内存放在一边，有一个临界指针，移动指针给对象分配一块内存，。

**空闲列表**：java堆内存不是规整的，虚拟机必须维护一个列表，记录哪块内存时可用的，分配给对象，更新表上记录。



Java堆内存是否规整取决于使用哪种垃圾回收器。使用Serial,ParNew等带压缩的垃圾回收器，系统采用的分配算法是指针碰撞，既简单又高效。

使用CMS清楚算法的收集器，理论上只能使用复杂的空闲列表来分配内存。

指针碰撞分配内存不是线程安全的，实际上虚拟机是采用CAS配上失败
重试的方式保证更新操作的原子性；   

另外一种是把内存分配的动作按照线程划分在不同的空间之中进
行， 即每个线程在Java堆中预先分配一小块内存， 称为本地线程分配缓冲（Thread Local AllocationBuffer， TLAB） ， 哪个线程要分配内存， 就在哪个线程的本地缓冲区中分配， 只有本地缓冲区用完了， 分配新的缓存区时才需要同步锁定。  



对象的内存分配完会初始化为当前数据类型的零值。

接下来， Java虚拟机还要对对象进行必要的设置， 例如这个对象是哪个类的实例、 如何才能找到
类的元数据信息、 对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才
计算） 、 对象的GC分代年龄等信息。 这些信息存放在对象的对象头（Object Header） 之中。 根据虚拟
机当前运行状态的不同， 如是否启用偏向锁等， 对象头会有不同的设置方式  



new指令之后会接着执行<init>
()方法， 按照程序员的意愿对对象进行初始化， 这样一个真正可用的对象才算完全被构造出来  

### 对象的内存布局

在HotSpot虚拟机中，对象在堆内存的存储布局可以划分为三个部分：**对象头**（Header）、**实例数据**（Instance Data）、和**对齐填充**（padding）

HotSpot虚拟机对象的对象头部分包括两类信息。 第一类是用于存储对象自身的运行时数据， 如哈希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等， 这部分数据的长度在32位和64位的虚拟机（未开启压缩指针） 中分别为32个比特和64个比特， 官方称它为“Mark Word”。 

对象需要存储的运行时数据很多， 其实已经超出了32、 64位Bitmap结构所能记录的最大限度， 但对象头里的信息是与对象自身定义的数据无关的额外存储成本， 考虑到虚拟机的空间效率， Mark Word被设计成一个有着动态定义的数据结构， 以便在极小的空间内存储尽量多的数据， 根据对象的状态复用自己的存储空间。 例如在32位的HotSpot虚拟机中， 如对象未被同步锁锁定的状态下， Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码， 4个比特用于存储对象分代年龄， 2个比特用于存储锁标志位， 1个比特固定为0， 在其他状态（轻量级锁定、 重量级锁定、 GC标记、 可偏向） 

![image-20200827162900268](img\jvm1.png)

对象头的另外一部分是**类型指针**， 即对象指向它的类型元数据的指针，  因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小， 但是如果数组的长度是不确定的， 将无法通过元数据中的信息推断出数组的大小。  



**实例数据部分是对象真正存储的有效信息**， 即我们在程序代码里面所定义的各种类型的字段内容， 无论是从父类继承下来的， 还是在子类中定义的字段都必须记录起来。 这部分的存储顺序会受到虚拟机分配策略参数（-XX:FieldsAllocationStyle参数） 和字段在Java源码中定义顺序的影响。
HotSpot虚拟机默认的分配顺序为longs/doubles、 ints、 shorts/chars、 bytes/booleans、 oops（OrdinaryObject Pointers， OOPs） ， 从以上默认的分配策略中可以看到， 相同宽度的字段总是被分配到一起存放， 在满足这个前提条件的情况下， 在父类中定义的变量会出现在子类之前。 如果HotSpot虚拟机的
+XX： CompactFields参数值为true（默认就为true） ， 那子类之中较窄的变量也允许插入父类变量的空隙之中， 以节省出一点点空间。  

**对齐填充**，占位符的. 由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，任何对象的大小都必须是8字节的整数倍。 对象头部分已经被精心设计成正好是8字节的倍数, 如果对象实例数据部分没有对齐的话， 就需要通过对齐填充来补全。  

### 对象的访问定位

Java程序会通过栈上的reference数据来操作堆上的具体对象  

主流的访问方式：句柄和直接指针。

如果使用**句柄访问**的话， Java堆中将可能会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自具体的地址信息， 
·如果使用**直接指针访问**的话， Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息， reference中存储的直接就是对象地址， 如果只是访问对象本身的话， 就不需要多一次间接访问的开销，

这两种对象访问方式各有优势， 使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址， 在对象被移动（垃圾收集时移动对象是非常普遍的行为） 时只会改变句柄中的实例数据指针， 而reference本身不需要被修改。  

直接指针访问速度快，

## 实战

除了程序计数器其他内存运行区域都又可能出现oom

### Java堆内存溢出

```
/**
 * @Author : lhk
 * @Description :
 * @Date : 2020/8/27 16:49
 * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 * -Xms初始的Heap的大小。
 * -Xmx最大Heap的大小。
 */
public class HeapOOM {
    static class OOMObject{

    }
    public static void main(String[] args) {
        List<OOMObject> list=new ArrayList<OOMObject>();
        while (true){
            list.add(new OOMObject());
        }
    }
}
```

```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```

### 虚拟机栈和本地方法栈溢出

对于HotSpot来说， -Xoss参数（设置本地方法栈大小） 虽然存在， 但实际上是没有任何效果的， 栈容量只能由-Xss参数来设定。

两种异常：  线程申请的栈深入大于虚拟机允许的最大深度，抛出StackOverflowError异常。  

扩容栈无法申请到足够的内存就会抛oom



### 方法区

jdk之后方法区被改成元空间，被放在直接内存，由操作系统直接管理。

·-XX： MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。
·-XX： MetaspaceSize： 指定元空间的初始空间大小， 以字节为单位，  

直接内存（Direct Memory） 的容量大小可通过-XX： MaxDirectMemorySize参数来指定， 如果不去指定， 则默认与Java堆最大值（由-Xmx指定） 一致，   

## 垃圾收集器和内存分配策略

### 判断对象是否存活

引用计数算法：在对象中添加一个引用计数器，有地方引用他就加1 ，引用失效就减1 ，为0时代表可回收。。问题是两个对象互相引用时，造成对象无法回收。

可达性分析算法：通过一系列GCRoot，从这些节点向下引用，形成一个引用链，某个对象到GCRoot没有任何引用链就会被回收。

## 垃圾收集算法

### 分代收集

把java堆内存分成新生代和老年代

Partial GC:部分收集

Major GC/Old GC :老年代垃圾收集

Minor GC/Young GC:新生代垃圾收集

Mixed GC: 混合收集

Full GC: 整堆收集

### 标记-清楚算法Mark-sweep

先标记再清除

缺点：1 执行效率不稳定，随对象增多效率降低

​			2 会产生内存碎片

### 标记-复制算法

只使用一半的内存，当一半内存用完时，把还存活的对象复制到另一半内存上，把另一半内存清除。不适合老年代使用，会有对象百分之百存活的

缺点：浪费内存

### 标记-整理算法

先标记，然后将存活的对象都移向一端。



## 经典垃圾收集器

### Serial收集器

单线程工作，必须stop the world 停掉所有用户线程。年轻代使用复制算法，老年代使用标记整理算法。

### Parnew 收集器

Parnew是Serial收集器的多线程版本。

### Parallel Scavenge收集器

Parallel Scavenge是一款新生代垃圾收集器，基于标记-复制算法。多线程

目标是达到一个可控制的吞吐量。吞吐量=用户代码运行时间➗用户代码运行时间+垃圾回收时间。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量， 分别是控制最大垃圾收集停顿时间
的-XX： MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX： GCTimeRatio参数。  

### Serial Old收集器

是serial的老年代版本。单线程

### Parallel Old 收集器

是Parallel Scavenge 收集器的老年代，支持多线程，基于标记-整理算法。

吞吐量优先

### CMS收集器

最短停顿时间为目标的收集器。

四个步骤：

1 初始标记  stw,单线程，标记一个GCRoot直接关联的对象，很快

2 并发标记  多线程，管理的对象整体遍历

3 重新标记 stw  多线程，

4 并发清除 

并发收集，低停顿收集器。

缺点：无法处理浮动垃圾



### Garbage First 收集器

G1宣告取代Parallel Scavenge加Parallel Old组合， 成为服务端模式下的默认垃圾收集器，  

G1是对整个堆进行垃圾回收，把内存划分成多个大小相等的独立区域（Region）

Region中还有一类特殊的Humongous区域， 专门用来存储大对象。 G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 每个Region的大小可以通过参数-XX： G1HeapRegionSize设定， 取值范围为1MB～32MB， 且应为2的N次幂。 而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中， G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待，
虽然G1仍然保留新生代和老年代的概念， 但新生代和老年代不再是固定的了， 它们都是一系列区域（不需要连续） 的动态集合。 G1收集器之所以能建立可预测的停顿时间模型， 是因为它将Region作为单次回收的最小单元， 即每次收集到的内存空间都是Region大小的整数倍， 这样可以有计划地避免
在整个Java堆中进行全区域的垃圾收集。 更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小， 价值即回收所获得的空间大小以及回收所需时间的经验值， 然后在后台维护一个优先级列表， 每次根据用户设定允许的收集停顿时间（使用参数-XX： MaxGCPauseMillis指定， 默认值是200毫秒） ， 优先处理回收价值收益最大的那些Region， 这也就是“Garbage First”名字的由来。
这种使用Region划分内存空间， 以及具有优先级的区域回收方式， 保证了G1收集器在有限的时间内获取尽可能高的收集效率  

收集步骤：

初始标记：stw

并发标记：与用户线程并发，

最终标记：对用户进程做一个短暂的停顿

筛选回收：更新Region的统计数据。

## 低延迟收集器

 衡量垃圾收集器的三项重要指标：内存占用，吞吐量，延迟

### Shenandoah 收集器

只有openJDK有，Shenandoah使用基于Region的布局，同样有着用于存放大对象的Humongous Region,默认回收策略同样优先回收价值最大的Region。不分代

并发标记、 

并发回收、 

并发引用更新  

### ZGC收集器

目标：再对吞吐量影响不大的情况下，实现低延迟

ZGC收集器是一款基于Region内存布局的， （暂时）不设分代的， 使用了读屏障、 染色指针和内存多重映射等技术来实现可并发的标记-整理算法的， 以低
延迟为首要目标的一款垃圾收集器。

内存布局：

​	小型Region：固定2MB，用于存放256kb

​	中型Region：32MB，用于存放256KB-4MB

​	大型Region：容量不固定，动态变化，但是必须是2MB的整数倍，用于存放4MB以上的大对象。大型Region值存放一个对象。

染色体指针技术：

## 垃圾收集器选择

![image-20200831103445069](img\jvm2.png)

![image-20200831103618063](img\jvm3.png)

![image-20200831103702740](img\jvm4.png)

## 对象的内存分配

### 对象优先在Eden区

大多数情况下，对象在新生代的Eden区分配，当Eden区没有足够空间时，会触发一次Minor GC

HotSpot虚拟机提供了-XX： +PrintGCDetails这个收集器日志参数， 告诉虚拟机在发生垃圾收集行为时打印内存回收日志， 并且在进程退出的时候输出当前的内存各区域分配情况  

-XX： Survivor-Ratio=8决定了新生代中Eden区与一个Survivor区的空间比例是8∶ 1  

### 大对象直接进入老年代

### 长期存活的对象将进入老年代

对象晋升老年代的年龄阈值， 可以通过参数-XX：MaxTenuringThreshold设置。默认15岁。

### 动态年龄判定

如果在Survivor空间中相同年龄所有对象大小的总和大于
Survivor空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代， 无须等到-XX：MaxTenuringThreshold中要求的年龄。    

### 空间分配担保

在发生Minor GC之前， 虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总
空间， 如果这个条件成立， 那这一次Minor GC可以确保是安全的。 如果不成立， 则虚拟机会先查看-XX： HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure） ； 如果允许， 那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于， 将尝试进行一次Minor GC， 尽管这次Minor GC是有风险的； 如果小于， 或者-XX：
HandlePromotionFailure设置不允许冒险， 那这时就要改为进行一次Full GC。  

## 基础故障处理工具

### jps：虚拟机进程状态工具

jps查看进程以及进程的id

jps -l能查看正在运行的进程

![image-20200831145923427](C:\Users\Sinosoft\Desktop\笔记\jvm5.png)

### jstat: 虚拟机统计信息监控工具

```
jstat -gc 2740 250 20
//2740是进程id ，每隔250毫秒发一次，发20次
```

![image-20200831150441130](img\jvm6.png)

### jinfo ：Java配置信息工具

jinfo可以实时观看和调整虚拟机各项参数。

jps -v 查看参数列表

jinfo [options] pid

### jmap :Java内存映射工具

生成堆转存快照。  在linux系统可以通过kill -3 生成堆转存快照

jmap的作用并不仅仅是为了获取堆转储快照， 它还可以查询finalize执行队列、 Java堆和方法区的详细信息， 如空间使用率、 当前用的是哪种收集器等。  

jmap[options] vmid

![image-20200831151055051](img\jvm7.png)

### jhat:虚拟机堆转快照分析工具

jhat命令和jmap搭配使用。jhat内置了为微型的web服务器，可以在分析之后再浏览器中查看，

### jstack：Java堆栈跟踪工具

jstack [option] vmid

![image-20200831154144769](img\jvm8.png)

## 可视化故障工具

### JHSDB：基于服务性代理的调试工具

JDK中提供了JCMD和JHSDB两个集成式的多功能工具箱  

### JConsole ：Java监视和管理控制台

通过JDK/bin目录下的jconsole.exe启动JCon-sole后， 会自动搜索出本机运行的所有虚拟机进程，  

### VisualVM:多合-故障处理工具

### Java Mission Control： 可持续在线的监控工具  



## 类文件结构

编写.java的文件，通过javac编译器编译成.class的字节码文件，可用虚拟机识别。

### Class文件结构

Class文件是一组以8个字节为基础单位的二进制流  。结构中只有两种数据类型： “无符号数”和“表”。   

·无符号数属于基本的数据类型， 以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个字节的无符号数， 无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串值。

·表是由多个无符号数或者其他表作为数据项构成的复合数据类型， 为了便于区分， 所有表的命名都习惯性地以“_info”结尾。 表用于描述有层次关系的复合结构的数据， 整个Class文件本质上也可以视作是一张表， 这张表由表6-1所示的数据项按严格顺序排列构成。  

#### 魔数与Class文件的版本

一个字节是8位2进制，是2位16进制。

每个Class文件的头4个字节被称为魔数（Magic Number） ， 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件  。

第5和第6个字节是次版本号（Minor Version） ， 第7和第8个字节是主版本号（Major Version） 。   

#### 常量池

紧接着主、 次版本号之后的是常量池入口， 常量池可以比喻为Class文件里的资源仓库， 它是Class文件结构中与其他项目关联最多的数据， 通常也是占用Class文件空间最大的数据项目之一  。由于常量池中常量的数量是不固定的， 所以在常量池的入口需要放置一项u2类型的数据， 代表常量池容量计数值（constant_pool_count） 。  

这个容量计数是从1而不是0开始的， 如图6-3所示， 常量池容量（偏移地址： 0x00000008） 为十六进制数0x0016， 即十进制的22， 这就代表常量池中有21项常量， 索引值范围为1～21。  

常量池中主要存放两大类常量： 字面量（Literal） 和符号引用（Symbolic References） 。 字面量比较接近于Java语言层面的常量概念， 如文本字符串、 被声明为final的常量值等。 而符号引用则属于编译原理方面的概念， 主要包括下面几类常量：
·被模块导出或者开放的包（Package）
·类和接口的全限定名（Fully Qualified Name）
·字段的名称和描述符（Descriptor）
·方法的名称和描述符
·方法句柄和方法类型（Method Handle、 Method Type、 Invoke Dynamic）
·动态调用点和动态常量（Dynamically-Computed Call Site、 Dynamically-Computed Constant）  



常量表中分别有17种不同类型的常量  

表结构起始的第一位是个u1类型的标志位（tag， 取值见表6-3中标志列） ， 代表着当前常量属于哪种常量类型。  

#### 访问标志

在常量池结束之后， 紧接着的2个字节代表访问标志（access_flags） ， 这个标志用于识别一些类或者接口层次的访问信息， 包括： 这个Class是类还是接口； 是否定义为public类型； 是否定义为abstract类型； 如果是类的话， 是否被声明为final；   

![image-20200904144229081](img\jvm9.png)

#### 类索引、 父类索引与接口索引集合  

类索引（this_class） 和父类索引（super_class） 都是一个u2类型的数据， 而接口索引集合（interfaces） 是一组u2类型的数据的集合， Class文件中由这三项数据来确定该类型的继承关系。 类索引用于确定这个类的全限定名， 父类索引用于确定这个类的父类的全限定名。 由于Java语言不允许多重继承， 所以父类索引只有一个， 除了java.lang.Object之外， 所有的Java类都有父类， 因此除了
java.lang.Object外， 所有Java类的父类索引都不为0。  

#### 字段表集合

字段可以包括的修饰符有字段的作用域（public、 private、 protected修饰
符） 、 是实例变量还是类变量（static修饰符） 、 可变性（final） 、 并发可见性（volatile修饰符， 是否强制从主内存读写） 、 可否被序列化（transient修饰符） 、 字段数据类型（基本类型、 对象、 数组） 、字段名称。 上述这些信息中， 各个修饰符都是布尔值， 要么有某个修饰符， 要么没有， 很适合使用标
志位来表示。 而字段叫做什么名字、 字段被定义为什么数据类型， 这些都是无法固定的， 只能引用常量池中的常量来描述。  

### 方法表集合

包括访问标志（access_flags） 、 名称索引（name_index） 、 描述符索引（descriptor_index） 、 属性表集合（attributes）   

## 虚拟机类加载机制

### 类加载的时机

生命周期：加载，验证，准备，解析，初始化，使用，卸载。

### 加载

1》通过一个类的全限定名来获取一个指定的二进制字节流

2》将这个字节流所代表的静态存储结构转换成方法区的运行时数据结构。

3》将内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

### 验证

确保Class文件的字节流中包含的信息符合JVM虚拟机规范。

**文件格式验证**：验证魔术，版本号，常量池。

**元数据验证**：语义分析，是否有父类，是否能被继承，是不是抽象类。

**字节码验证**：通过数据流分析和控制流分析， 确定程序语义是合法的、 符合逻辑的。 在第二阶段对元数据信息中的数据类型校验完毕以后， 这阶段就要对类的方法体（Class文件中的Code属性） 进行校验分析， 保证被校验类的方法在运行时不会做出危害虚拟机安全的行为

**符号引用验证**：验证引用能不能找到类。

### 准备

为类定义变量，分配内存，设置类变量初始值，（不包含实例变量）

### 解析

Jvm虚拟机将常量池符号引用替换成直接引用，

### 初始化

初始化阶段就是执行类构造器<clinit>()方法，必须先调用父类的构造。

## 类加载器

通过一个类的全限定名来描述该类的二进制字节流，这个动作放到虚拟机外部实现，实现这个动作的代码就叫“类加载器”。

### 类与类加载器

任意一个类，必须由加载它的类加载器和类本身共同确立在Java虚拟机中的唯一性。

### 双亲委派模型

在虚拟机的角度看只有两种类加载器：一种是启动类加载器，这个类是C++语言写的，另一种是其他类加载器。全部继承java.lang.ClassLoader

**启动类加载器**：存放在JAVA_HOME\lib目录虚拟机能够识别。

**扩展类加载器**：负责加载JAVA_HOME\lib\ext目录。

**应用程序加载器**：是ClassLoader类中的getSystemClassLoader()的返回值，负责加载用户类路径上的所有类库

![image-20200907171438630](img\jvm10.png)

用户可以自定义类加载器。

双亲委派模型：要求除了启动类加载器，其他加载器都必须有父类加载器。

工作过程：如果一个类加载器收到了类加载的请求，首先不去尝试加载这个类，而是把请求委派给父类加载器，每层都如此，父类无法加载，子类加载器才会尝试去加载。

## Java模块化系统

在jdk9中引入模块化系统，为了实现模块化的关键目标-可配置的封装隔离机制。

JDK 9以后， 如果启用了模块化进行封装， 模块就可以声明对其他模块的显式依赖， 这样Java虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备， 如有缺失那就直接启动失败， 从而避免了很大一部分[1]由于类型依赖而引发的运行时异常  。



可配置的封装隔离机制还解决了原来类路径上跨JAR文件的public类型的可访问性问题。 JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们， 模块提供了更精细的可访问性控制， 必须明确声明其中哪一些public的类型可以被其他哪一些模块访问 。

### 模块的兼容性

jdk9提出了与类路径相对应的模块路径，某个类库到底是模块还是jar包，只取决于它存放在哪个路径上。

模块：模块路径下的具名模块只能访问到它依赖定义中依赖的模块和包。匿名模块的所有内容对具名模块来说是不可见的。

在JDK 9时加入Class文件格式的Module属性， 里面有module_version_index这样的字段， 用户可以在编译时使用“javac--module-version”来指定模块版本， 在Java类库API中也存在java.lang.module.ModuleDescriptor.Version这样的接口可以在运行时获取到模块的版本号。 这一切迹象都证明了Java模块化系统对版本号的支持本可以不局限在编译期  。

### 模块化下的类加载器

扩展类加载器被平台加载器取代，

## 虚拟机字节码执行引擎

解释执行和编译执行

### 运行时栈帧结构

java虚拟机栈的最基本的执行单元，栈帧，用于支持虚拟机进行方法调用和方法执行背后的数据结构。

栈帧存储了局部变量表，操作数栈，动态链接和方法返回地址。

#### 局部变量表

局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部的局部变量。

#### 操作数栈

也叫做操作栈，是一个后入先出栈，操作数栈的最大深度在编译时呗写入Code属性，元素可以是任意Java数据类型。

#### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中动态连接。运行期间符号引用变成直接引用的就是动态连接。

#### 方法返回地址

正常退出。

异常退出。都回到方法调用的位置。

