JVM虚拟机

## Java虚拟机的发展史

### 虚拟机始祖： Sun Classic/Exact VM  

### 武林盟主HotSpot VM

 JDK 1.3时， HotSpot VM成为默认虚拟机 ， 它名称中的HotSpot指的就是它的热点代码探测技术  ，HotSpot虚拟机的热点代码探测能力可以通过执行计数器
找出最具有编译价值的代码， 然后通知即时编译器以方法为单位进行编译。 如果一个方法被频繁调
用， 或方法中有效循环次数很多， 将会分别触发标准即时编译和栈上替换编译（On-StackReplacement， OSR） 行为[1]。   

通过编译器与解释器恰当地协同工作， 可以在最优化的程序响应时间与
最佳执行性能中取得平衡， 而且无须等待本地代码输出才能执行程序， 即时编译的时间压力也相对减
小， 这样有助于引入更复杂的代码优化技术， 输出质量更高的本地代码。  



### 小家碧玉： Mobile/Embedded VM  

手机上的虚拟机

### 天下第二： BEA JRockit/IBM J9 VM  

因此JRockit内部不包含解释器实现， 全部代
码都靠即时编译器编译后执行。 除此之外， JRockit的垃圾收集器和Java Mission Control故障处理套件
等部分的实现， 在当时众多的Java虚拟机中也处于领先水平。 JRockit随着BEA被Oracle收购， 现已不再
继续发展， 永远停留在R28版本， 这是JDK 6版JRockit的代号  

### 软硬合璧： BEA Liquid VM/Azul VM  

软硬件配合工作的专有虚拟机  

这类专有虚拟机的代表是BEA Liquid VM和Azul VM。  

### 挑战者： Apache Harmony/Google Android Dalvik VM  

尤其是对Android的发展起了很大推动作用。  

### 没有成功， 但并非失败： Microsoft JVM及其他  

### 百家争鸣  

KVM中的K是“Kilobyte”的意思， 它强调简单、 轻量、 高度可移植， 但是运行速度比较慢。 在
Android、 iOS等智能手机操作系统出现前曾经在手机平台上得到非常广泛应用。  

Java Card VM
JCVM是Java虚拟机很小的一个子集， 裁减了许多模块但通常支持绝大多数的常用加密算法。
JCVM必须精简到能放入智能卡、 SIM卡、 银行信用卡、 借记卡内， 负责对Java Applet程序进行解释执行。
·Squawk VM
Squawk VM是由Sun开发， 运行于Sun SPOT（Sun Small Programmable Object Tech-nology， 一种手持的Wi-Fi设备） ， 也曾经运用于Java Card。 这是一个Java代码比重很高的嵌入式虚拟机实现， 其中诸如类加载器、 字节码验证器、 垃圾收集器、 解释器、 编译器和线程调度都是用Java语言完成的， 仅仅靠C语言编写设备I/O和必要的本地代码。
·JavaInJava
JavaInJava是Sun公司在1997年～1998年间所研发的一个实验室性质的虚拟机， 从名字就可以看出， 它试图以Java语言来实现Java语言本身的运行环境， 既所谓的“元循环”（Meta-Circular， 是指使用
语言自身来实现其运行环境） 虚拟机。 它必须运行在另外一个宿主虚拟机之上， 内部没有即时编译器， 代码只能以解释模式执行。 在上世纪末主流原生的Java虚拟机都未能很好解决性能问题的时代，
开发这种项目， 其执行速度大家可想而知， 不过通过元循环证明一门语言可以自举， 是具有它的研究价值的。
·Maxine VM
Maxine VM和上面的JavaInJava非常相似， 它也是一个几乎全部以Java代码实现（只有用于启动Java虚拟机的加载器使用C语言编写） 的元循环Java虚拟机。 这个项目于2005年开始， 到现在仍然在发
展之中， 比起JavaInJava， Maxine VM的执行效率就显得靠谱得多， 它有先进的即时编译器和垃圾收集
器， 可在宿主模式或独立模式下执行， 其执行效率已经接近HotSpot虚拟机Client模式的水平。 后来有
了从C1X编译器演进而来的Graal编译器的支持， 就更加如虎添翼， 执行效率有了进一步飞跃。 Graal编
译器现在已经是HotSpot的默认组件， 是未来代替HotSpot中服务端编译器的希望。
·Jikes RVM
Jikes RVM是IBM开发的专门用来研究Java虚拟机实现技术的项目。 曾用名为Jalapeño。 与
JavaInJava和Maxine一样， 它也是一个元循环虚拟机。
·IKVM.NET
这是一个基于微软.NET框架实现的Java虚拟机， 并借助Mono获得一定的跨平台能力。 IKVM.NET
的目标第一眼看起来的确很奇怪， 可能在某些特殊情况下， 在.NET上使用某些流行的Java库也许真的
不算是伪需求？ IKVM.NET可以将Class文件编译成.NET Assembly， 在任意的CLI上运行。  

## 自动内存管理

### 运行时数据区域

#### 程序计数器

当前线程所执行的行号指示器，此内存区域不会发生OutOfMemoryError

#### 虚拟机栈

线程私有

生命周期与线程相同

方法执行会创建栈帧，栈帧中存储局部变量表，操作数栈，动态连接，方法出口信息等。

一个方法的调用和完成对应一个栈帧的入栈和出栈。

局部变量表中存放了编译期可知的8种基本数据类型，对象引用和字节码指令的地址。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot） 来表示， 其中64位长度的long和double类型的数据会占用两个变量槽， 其余的数据类型只占用一个。   



HotSpot虚拟机的栈容量是不可以动态扩展的  

#### 本地方法栈

本地方法栈（Native Method Stacks） 与虚拟机栈所发挥的作用是非常相似的， 其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码） 服务， 而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。  

与虚拟机栈一样， 本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。  

#### Java堆

Java堆（Java Heap） 是虚拟机所管理的内存中最大的一块  ，线程共享。

此内存区域的唯一目的就是存放对象实例  和数组

Java堆是垃圾收集器管理的内存区域 ，因为被叫GC堆

Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空
间”“To Survivor空间”等名词  。

Java堆既可以被实现成固定大小的， 也可以是可扩展的， 不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定） 。 如果在Java堆中没有内存完成实例分配， 并且堆也无法再扩展时， Java虚拟机将会抛出OutOfMemoryError异常。  

#### 方法区

与Java堆一样都是线程共享的，用于存储虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等信息，。

永久代实现方法区

jdk1.8 以后方法区被放入java内存中，有操作系统管理

#### 运行时常量池

运行时常量池（Runtime Constant Pool） 是方法区的一部分。 Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外， 还有一项信息是常量池表（Constant Pool Table） ， 用于存放编译期生成的各种字面量与符号引用， 这部分内容将在类加载后存放到方法区的运行时常量池中。  

既然运行时常量池是方法区的一部分， 自然受到方法区内存的限制， 当常量池无法再申请到内存
时会抛出OutOfMemoryError异常。  

#### 直接内存

直接内存（Direct Memory）,不是虚拟机运行时数据区，这部分内存也被频繁地使用， 而且也可能导致OutOfMemoryError异常出现  。

在JDK 1.4中新加入了NIO（New Input/Output） 类， 引入了一种基于通道（Channel） 与缓冲区（Buffer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据  。

## HotSpot虚拟机对象探秘  

### 对象的创建

new关键字，给对象在堆内存上给对象分配内存。

指针碰撞：java堆内存时绝对规整的，空闲的内存放在一边，有一个临界指针，移动指针给对象分配一块内存，。

空闲列表：java堆内存不是规整的，虚拟机必须维护一个列表，记录哪块内存时可用的，分配给对象，更新表上记录。



Java堆内存是否规整取决于使用哪种垃圾回收器。使用Serial,ParNew等带压缩的垃圾回收器，系统采用的分配算法是指针碰撞，既简单又高效。

使用CMS清楚算法的收集器，理论上只能使用复杂的空闲列表来分配内存。

指针碰撞分配内存不是线程安全的，实际上虚拟机是采用CAS配上失败
重试的方式保证更新操作的原子性；   

另外一种是把内存分配的动作按照线程划分在不同的空间之中进
行， 即每个线程在Java堆中预先分配一小块内存， 称为本地线程分配缓冲（Thread Local AllocationBuffer， TLAB） ， 哪个线程要分配内存， 就在哪个线程的本地缓冲区中分配， 只有本地缓冲区用完了， 分配新的缓存区时才需要同步锁定。  



对象的内存分配完会初始化为当前数据类型的零值。

接下来， Java虚拟机还要对对象进行必要的设置， 例如这个对象是哪个类的实例、 如何才能找到
类的元数据信息、 对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才
计算） 、 对象的GC分代年龄等信息。 这些信息存放在对象的对象头（Object Header） 之中。 根据虚拟
机当前运行状态的不同， 如是否启用偏向锁等， 对象头会有不同的设置方式  



new指令之后会接着执行<init>
()方法， 按照程序员的意愿对对象进行初始化， 这样一个真正可用的对象才算完全被构造出来  

### 对象的内存布局

在HotSpot虚拟机中，对象在堆内存的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）、和对齐填充（padding）

HotSpot虚拟机对象的对象头部分包括两类信息。 第一类是用于存储对象自身的运行时数据， 如哈希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等， 这部分数据的长度在32位和64位的虚拟机（未开启压缩指针） 中分别为32个比特和64个比特， 官方称它为“Mark Word”。 

对象需要存储的运行时数据很多， 其实已经超出了32、 64位Bitmap结构所能记录的最大限度， 但对象头里的信息是与对象自身定义的数据无关的额外存储成本， 考虑到虚拟机的空间效率， Mark Word被设计成一个有着动态定义的数据结构， 以便在极小的空间内存储尽量多的数据， 根据对象的状态复用自己的存储空间。 例如在32位的HotSpot虚拟机中， 如对象未被同步锁锁定的状态下， Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码， 4个比特用于存储对象分代年龄， 2个比特用于存储锁标志位， 1个比特固定为0， 在其他状态（轻量级锁定、 重量级锁定、 GC标记、 可偏向） 

![image-20200827162900268](img\jvm1.png)

对象头的另外一部分是**类型指针**， 即对象指向它的类型元数据的指针，  因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小， 但是如果数组的长度是不确定的， 将无法通过元数据中的信息推断出数组的大小。  



**实例数据部分是对象真正存储的有效信息**， 即我们在程序代码里面所定义的各种类型的字段内容， 无论是从父类继承下来的， 还是在子类中定义的字段都必须记录起来。 这部分的存储顺序会受到虚拟机分配策略参数（-XX:FieldsAllocationStyle参数） 和字段在Java源码中定义顺序的影响。
HotSpot虚拟机默认的分配顺序为longs/doubles、 ints、 shorts/chars、 bytes/booleans、 oops（OrdinaryObject Pointers， OOPs） ， 从以上默认的分配策略中可以看到， 相同宽度的字段总是被分配到一起存放， 在满足这个前提条件的情况下， 在父类中定义的变量会出现在子类之前。 如果HotSpot虚拟机的
+XX： CompactFields参数值为true（默认就为true） ， 那子类之中较窄的变量也允许插入父类变量的空隙之中， 以节省出一点点空间。  

**对齐填充**，占位符的. 由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，任何对象的大小都必须是8字节的整数倍。 对象头部分已经被精心设计成正好是8字节的倍数, 如果对象实例数据部分没有对齐的话， 就需要通过对齐填充来补全。  

### 对象的访问定位

Java程序会通过栈上的reference数据来操作堆上的具体对象  

主流的访问方式：句柄和直接指针。

如果使用**句柄访问**的话， Java堆中将可能会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自具体的地址信息， 
·如果使用**直接指针访问**的话， Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息， reference中存储的直接就是对象地址， 如果只是访问对象本身的话， 就不需要多一次间接访问的开销，

这两种对象访问方式各有优势， 使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址， 在对象被移动（垃圾收集时移动对象是非常普遍的行为） 时只会改变句柄中的实例数据指针， 而reference本身不需要被修改。  

直接指针访问速度快，

## 实战

除了程序计数器其他内存运行区域都又可能出现oom

### Java堆内存溢出

```
/**
 * @Author : lhk
 * @Description :
 * @Date : 2020/8/27 16:49
 * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 * -Xms初始的Heap的大小。
 * -Xmx最大Heap的大小。
 */
public class HeapOOM {
    static class OOMObject{

    }
    public static void main(String[] args) {
        List<OOMObject> list=new ArrayList<OOMObject>();
        while (true){
            list.add(new OOMObject());
        }
    }
}
```

```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```

### 虚拟机栈和本地方法栈溢出

对于HotSpot来说， -Xoss参数（设置本地方法栈大小） 虽然存在， 但实际上是没有任何效果的， 栈容量只能由-Xss参数来设定。

两种异常：  线程申请的栈深入大于虚拟机允许的最大深度，抛出StackOverflowError异常。  

扩容栈无法申请到足够的内存就会抛oom



### 方法区

jdk之后方法区被改成元空间，被放在直接内存，由操作系统直接管理。

·-XX： MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。
·-XX： MetaspaceSize： 指定元空间的初始空间大小， 以字节为单位，  

直接内存（Direct Memory） 的容量大小可通过-XX： MaxDirectMemorySize参数来指定， 如果不去指定， 则默认与Java堆最大值（由-Xmx指定） 一致，   

## 垃圾收集器和内存分配策略

### 判断对象是否存活

引用计数算法：在对象中添加一个引用计数器，有地方引用他就加1 ，引用失效就减1 ，为0时代表可回收。。问题是两个对象互相引用时，造成对象无法回收。

可达性分析算法：通过一系列GCRoot，从这些节点向下引用，形成一个引用链，某个对象到GCRoot没有任何引用链就会被回收。

## 垃圾收集算法

### 分代收集

把java堆内存分成新生代和老年代

Partial GC:部分收集

Major GC/Old GC :老年代垃圾收集

Minor GC/Young GC:新生代垃圾收集

Mixed GC: 混合收集

Full GC: 整堆收集

### 标记-清楚算法Mark-sweep

先标记再清除

缺点：1 执行效率不稳定，随对象增多效率降低

​			2 会产生内存碎片

### 标记-复制算法

只使用一半的内存，当一半内存用完时，把还存活的对象复制到另一半内存上，把另一半内存清除。不适合老年代使用，会有对象百分之百存活的

缺点：浪费内存

### 标记-整理算法

先标记，然后将存活的对象都移向一端。



## 经典垃圾收集器

### Serial收集器

单线程工作，必须stop the world 停掉所有用户线程。年轻代使用复制算法，老年代使用标记整理算法。

### Parnew 收集器

Parnew是Serial收集器的多线程版本。

### Parallel Scavenge收集器

Parallel Scavenge是一款新生代垃圾收集器，基于标记-复制算法。多线程

目标是达到一个可控制的吞吐量。吞吐量=用户代码运行时间➗用户代码运行时间+垃圾回收时间。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量， 分别是控制最大垃圾收集停顿时间
的-XX： MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX： GCTimeRatio参数。  

### Serial Old收集器

是serial的老年代版本。单线程

### Parallel Old 收集器

是Parallel Scavenge 收集器的老年代，支持多线程，基于标记-整理算法。

吞吐量优先

### CMS收集器

最短停顿时间为目标的收集器。

四个步骤：

1 初始标记  stw,单线程，标记一个GCRoot直接关联的对象，很快

2 并发标记  多线程，管理的对象整体遍历

3 重新标记 stw  多线程，

4 并发清除 

并发收集，低停顿收集器。

缺点：无法处理浮动垃圾



### Garbage First 收集器

G1宣告取代Parallel Scavenge加Parallel Old组合， 成为服务端模式下的默认垃圾收集器，  

G1是对整个堆进行垃圾回收，把内存划分成多个大小相等的独立区域（Region）

Region中还有一类特殊的Humongous区域， 专门用来存储大对象。 G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。 每个Region的大小可以通过参数-XX： G1HeapRegionSize设定， 取值范围为1MB～32MB， 且应为2的N次幂。 而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中， G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待，
虽然G1仍然保留新生代和老年代的概念， 但新生代和老年代不再是固定的了， 它们都是一系列区域（不需要连续） 的动态集合。 G1收集器之所以能建立可预测的停顿时间模型， 是因为它将Region作为单次回收的最小单元， 即每次收集到的内存空间都是Region大小的整数倍， 这样可以有计划地避免
在整个Java堆中进行全区域的垃圾收集。 更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小， 价值即回收所获得的空间大小以及回收所需时间的经验值， 然后在后台维护一个优先级列表， 每次根据用户设定允许的收集停顿时间（使用参数-XX： MaxGCPauseMillis指定， 默认值是200毫秒） ， 优先处理回收价值收益最大的那些Region， 这也就是“Garbage First”名字的由来。
这种使用Region划分内存空间， 以及具有优先级的区域回收方式， 保证了G1收集器在有限的时间内获取尽可能高的收集效率  

收集步骤：

初始标记：stw

并发标记：与用户线程并发，

最终标记：对用户进程做一个短暂的停顿

筛选回收：更新Region的统计数据。

## 低延迟收集器

 衡量垃圾收集器的三项重要指标：内存占用，吞吐量，延迟

### Shenandoah 收集器

只有openJDK有，Shenandoah使用基于Region的布局，同样有着用于存放大对象的Humongous Region,默认回收策略同样优先回收价值最大的Region。不分代

并发标记、 

并发回收、 

并发引用更新  

### ZGC收集器

目标：再对吞吐量影响不大的情况下，实现低延迟

ZGC收集器是一款基于Region内存布局的， （暂时）不设分代的， 使用了读屏障、 染色指针和内存多重映射等技术来实现可并发的标记-整理算法的， 以低
延迟为首要目标的一款垃圾收集器。

内存布局：

​	小型Region：固定2MB，用于存放256kb

​	中型Region：32MB，用于存放256KB-4MB

​	大型Region：容量不固定，动态变化，但是必须是2MB的整数倍，用于存放4MB以上的大对象。大型Region值存放一个对象。

染色体指针技术：

## 垃圾收集器选择

![image-20200831103445069](img\jvm2.png)

![image-20200831103618063](img\jvm3.png)

![image-20200831103702740](img\jvm4.png)

## 对象的内存分配

### 对象优先在Eden区

大多数情况下，对象在新生代的Eden区分配，当Eden区没有足够空间时，会触发一次Minor GC

HotSpot虚拟机提供了-XX： +PrintGCDetails这个收集器日志参数， 告诉虚拟机在发生垃圾收集行为时打印内存回收日志， 并且在进程退出的时候输出当前的内存各区域分配情况  

-XX： Survivor-Ratio=8决定了新生代中Eden区与一个Survivor区的空间比例是8∶ 1  

### 大对象直接进入老年代

### 长期存活的对象将进入老年代

对象晋升老年代的年龄阈值， 可以通过参数-XX：MaxTenuringThreshold设置。默认15岁。

### 动态年龄判定

如果在Survivor空间中相同年龄所有对象大小的总和大于
Survivor空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代， 无须等到-XX：MaxTenuringThreshold中要求的年龄。    

### 空间分配担保

在发生Minor GC之前， 虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总
空间， 如果这个条件成立， 那这一次Minor GC可以确保是安全的。 如果不成立， 则虚拟机会先查看-XX： HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure） ； 如果允许， 那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于， 将尝试进行一次Minor GC， 尽管这次Minor GC是有风险的； 如果小于， 或者-XX：
HandlePromotionFailure设置不允许冒险， 那这时就要改为进行一次Full GC。  

## 基础故障处理工具

### jps：虚拟机进程状态工具

jps查看进程以及进程的id

jps -l能查看正在运行的进程

![image-20200831145923427](C:\Users\Sinosoft\Desktop\笔记\jvm5.png)

### jstat: 虚拟机统计信息监控工具

```
jstat -gc 2740 250 20
//2740是进程id ，每隔250毫秒发一次，发20次
```

![image-20200831150441130](img\jvm6.png)

### jinfo ：Java配置信息工具

jinfo可以实时观看和调整虚拟机各项参数。

jps -v 查看参数列表

jinfo [options] pid

### jmap :Java内存映射工具

生成堆转存快照。  在linux系统可以通过kill -3 生成堆转存快照

jmap的作用并不仅仅是为了获取堆转储快照， 它还可以查询finalize执行队列、 Java堆和方法区的详细信息， 如空间使用率、 当前用的是哪种收集器等。  

jmap[options] vmid

![image-20200831151055051](img\jvm7.png)

### jhat:虚拟机堆转快照分析工具

jhat命令和jmap搭配使用。jhat内置了为微型的web服务器，可以在分析之后再浏览器中查看，

### jstack：Java堆栈跟踪工具

jstack [option] vmid

![image-20200831154144769](img\jvm8.png)

## 可视化故障工具

### JHSDB：基于服务性代理的调试工具

JDK中提供了JCMD和JHSDB两个集成式的多功能工具箱  

### JConsole ：Java监视和管理控制台

通过JDK/bin目录下的jconsole.exe启动JCon-sole后， 会自动搜索出本机运行的所有虚拟机进程，  

### VisualVM:多合-故障处理工具

### Java Mission Control： 可持续在线的监控工具  